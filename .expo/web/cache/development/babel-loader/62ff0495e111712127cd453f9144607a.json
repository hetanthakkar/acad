{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _jsxFileName = \"C:\\\\Users\\\\codemaxx\\\\Desktop\\\\iBlood\\\\node_modules\\\\react-native-maps\\\\lib\\\\web\\\\Leaflet\\\\Marker.js\";\nimport * as React from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport RNImage from \"react-native-web/dist/exports/Image\";\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Text from \"react-native-web/dist/exports/Text\";\nimport { convertCoordinate } from \"./utils/coordinates\";\nimport { parseIconProps } from \"./utils/icons\";\nimport createLogger from \"../utils/createLogger\";\nimport { transformPathEvents } from \"./utils/events\";\nimport { createPortal } from 'react-dom';\nimport { DivIcon, marker, Marker as LeafletMarker } from 'leaflet';\nimport * as RL from 'react-leaflet';\nimport { MapLayer, Marker, Popup } from 'react-leaflet';\nimport { difference } from 'lodash';\nvar logger = createLogger('Leaflet', 'Marker');\n\nvar ExpoMarker = function (_React$Component) {\n  _inherits(ExpoMarker, _React$Component);\n\n  function ExpoMarker(props) {\n    var _this;\n\n    _classCallCheck(this, ExpoMarker);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ExpoMarker).call(this, props));\n    _this.state = {\n      position: convertCoordinate(props.coordinate)\n    };\n    return _this;\n  }\n\n  _createClass(ExpoMarker, [{\n    key: \"showCallout\",\n    value: function showCallout() {\n      this.ref.leafletElement.openPopup();\n    }\n  }, {\n    key: \"hideCallout\",\n    value: function hideCallout() {\n      this.ref.leafletElement.closePopup();\n    }\n  }, {\n    key: \"setNativeProps\",\n    value: function setNativeProps(_ref) {\n      var coordinate = _ref.coordinate,\n          props = _objectWithoutProperties(_ref, [\"coordinate\"]);\n\n      if (coordinate) {\n        this.setState({\n          position: convertCoordinate(coordinate)\n        });\n      }\n\n      logger.unsupported(props);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.coordinate !== this.props.coordinate) {\n        this.setState({\n          position: convertCoordinate(nextProps.coordinate)\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          identifier = _this$props.identifier,\n          reuseIdentifier = _this$props.reuseIdentifier,\n          title = _this$props.title,\n          description = _this$props.description,\n          testID = _this$props.testID,\n          image = _this$props.image,\n          icon = _this$props.icon,\n          opacity = _this$props.opacity,\n          coordinate = _this$props.coordinate,\n          draggable = _this$props.draggable,\n          flat = _this$props.flat,\n          tracksViewChanges = _this$props.tracksViewChanges,\n          tracksInfoWindowChanges = _this$props.tracksInfoWindowChanges,\n          stopPropagation = _this$props.stopPropagation,\n          onSelect = _this$props.onSelect,\n          onDeselect = _this$props.onDeselect,\n          onCalloutPress = _this$props.onCalloutPress,\n          pinColor = _this$props.pinColor,\n          props = _objectWithoutProperties(_this$props, [\"identifier\", \"reuseIdentifier\", \"title\", \"description\", \"testID\", \"image\", \"icon\", \"opacity\", \"coordinate\", \"draggable\", \"flat\", \"tracksViewChanges\", \"tracksInfoWindowChanges\", \"stopPropagation\", \"onSelect\", \"onDeselect\", \"onCalloutPress\", \"pinColor\"]);\n\n      var markerTitle = description ? title + \"\\n\" + description : title;\n      var position = this.state.position;\n      var leafletIcon = parseIconProps(_objectSpread({\n        icon: icon,\n        image: image\n      }, props));\n\n      var markerProps = _objectSpread({}, props, transformPathEvents(props), {\n        id: identifier,\n        opacity: opacity,\n        draggable: draggable,\n        title: markerTitle,\n        position: position\n      });\n\n      var isCustom = false;\n\n      if (leafletIcon) {\n        isCustom = true;\n        markerProps.icon = leafletIcon;\n      }\n\n      if (!isCustom && props.children) {\n        React.Children.forEach(props.children, function (child, index) {\n          if (!isCustom && child.type.name !== 'MapCallout') {\n            isCustom = true;\n          }\n        });\n      }\n\n      if (isCustom) {\n        return React.createElement(ExpoDivIcon, _extends({\n          ref: function ref(_ref2) {\n            return _this2.ref = _ref2;\n          }\n        }, markerProps, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 116\n          }\n        }));\n      } else if (pinColor) {\n        return React.createElement(ExpoDivIcon, _extends({\n          ref: function ref(_ref3) {\n            return _this2.ref = _ref3;\n          }\n        }, markerProps, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 119\n          }\n        }), React.createElement(View, {\n          style: {\n            backgroundColor: pinColor,\n            width: '3rem',\n            height: '3rem',\n            display: 'block',\n            position: 'relative',\n            borderRadius: '3rem',\n            borderBottomEndRadius: 0,\n            transform: [{\n              rotate: '45deg'\n            }],\n            borderWidth: 1,\n            borderStyle: 'solid',\n            borderColor: '#fff'\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 120\n          }\n        }), markerProps.children, React.createElement(StandardCallout, {\n          title: title,\n          description: description,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 136\n          }\n        }));\n      }\n\n      return React.createElement(ExpoStandardIcon, _extends({\n        ref: function ref(_ref4) {\n          return _this2.ref = _ref4;\n        }\n      }, markerProps, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 142\n        }\n      }), markerProps.children, (title || description) && React.createElement(StandardCallout, {\n        title: title,\n        description: description,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 144\n        }\n      }));\n    }\n  }]);\n\n  return ExpoMarker;\n}(React.Component);\n\nexport { ExpoMarker as default };\n\nvar FullSizeImage = function (_React$Component2) {\n  _inherits(FullSizeImage, _React$Component2);\n\n  function FullSizeImage() {\n    var _getPrototypeOf2;\n\n    var _this3;\n\n    _classCallCheck(this, FullSizeImage);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this3 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FullSizeImage)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this3.state = {\n      size: {}\n    };\n    return _this3;\n  }\n\n  _createClass(FullSizeImage, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this4 = this;\n\n      var img = new Image();\n      img.src = this.props.source.uri ? this.props.source.uri : this.props.source;\n\n      img.onload = function () {\n        _this4.setState({\n          size: {\n            width: img.width / PixelRatio.get(),\n            height: img.height / PixelRatio.get()\n          }\n        });\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(RNImage, _extends({\n        testID: \"expo-maps-marker-full-size-image\"\n      }, this.props, {\n        style: [this.props.style, this.state.size],\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 169\n        }\n      }));\n    }\n  }]);\n\n  return FullSizeImage;\n}(React.Component);\n\nfunction StandardCallout(_ref5) {\n  var title = _ref5.title,\n      description = _ref5.description;\n  return React.createElement(Popup, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 198\n    }\n  }, React.createElement(View, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 199\n    }\n  }, title && React.createElement(Text, {\n    style: {\n      fontWeight: 'bold'\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 200\n    }\n  }, title), description && React.createElement(Text, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 201\n    }\n  }, description)));\n}\n\nExpoMarker.defaultProps = {\n  centerOffset: null,\n  calloutOffset: null,\n  anchor: [0.5, 1],\n  calloutAnchor: [0.5, 0],\n  stopPropagation: false,\n  draggable: false,\n  opacity: 1.0\n};\n\nvar ExpoCustomMarker = function (_MapLayer) {\n  _inherits(ExpoCustomMarker, _MapLayer);\n\n  function ExpoCustomMarker() {\n    var _getPrototypeOf3;\n\n    var _this5;\n\n    _classCallCheck(this, ExpoCustomMarker);\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    _this5 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(ExpoCustomMarker)).call.apply(_getPrototypeOf3, [this].concat(args)));\n\n    _this5.updateAnchor = function (anchor, element) {\n      if (!_this5.leafletElement.getElement()) return;\n\n      var iconAnchor = _this5.getRelativePointFromRect(anchor, element || _this5.leafletElement.getElement().getBoundingClientRect());\n\n      logger.log('toAnchor: ', iconAnchor, _this5.leafletElement.getElement().getBoundingClientRect());\n      _this5.icon.options.iconAnchor = iconAnchor;\n      _this5.leafletElement.getElement().style.marginLeft = -iconAnchor.x + 'px';\n      _this5.leafletElement.getElement().style.marginTop = -iconAnchor.y + 'px';\n    };\n\n    _this5.updateCalloutAnchor = function (anchor, element) {\n      if (!_this5.leafletElement.getElement()) return;\n      _this5.icon.options.popupAnchor = _this5.getPopupRelativePointFromRect(anchor, element || _this5.leafletElement.getElement().getBoundingClientRect());\n    };\n\n    _this5.getIconElement = function () {\n      var element = _this5.leafletElement.getElement();\n\n      if (!element) return null;\n      return element.querySelector('[data-testid=\"expo-maps-marker-full-size-image\"]');\n    };\n\n    _this5.getRectWithIcon = function () {\n      var container = _this5.rect;\n\n      var iconElement = _this5.getIconElement();\n\n      if (!iconElement) return _this5.rect;\n      var icon = iconElement.getBoundingClientRect();\n      var leftMost = Math.min(icon.x, container.x);\n      var rightMost = Math.max(icon.x + icon.width, container.x + container.width);\n      var topMost = Math.min(icon.y, container.y);\n      var bottomMost = Math.max(icon.y + icon.height, container.y + container.height);\n      return {\n        width: rightMost - leftMost,\n        height: bottomMost - topMost\n      };\n    };\n\n    _this5.onLayoutDidUpdate = function () {\n      var rect = _this5.getRectWithIcon();\n\n      _this5.updateAnchor(_this5.props.anchor, rect);\n\n      _this5.updateCalloutAnchor(_this5.props.calloutAnchor, rect);\n    };\n\n    _this5.observeElementLayout = function (element) {\n      var resizeObserver = new ResizeObserver(function () {\n        _this5.onLayoutDidUpdate();\n      }, element);\n      resizeObserver.observe(element);\n      return resizeObserver;\n    };\n\n    _this5.observeLayout = function (container) {\n      if (!_this5.resizeObserver) {\n        _this5.resizeObserver = _this5.observeElementLayout(container);\n      }\n\n      var image = container.querySelector('[data-testid=\"expo-maps-marker-full-size-image\"]');\n\n      if (image) {\n        _this5.observeElementLayout(image);\n      }\n    };\n\n    return _this5;\n  }\n\n  _createClass(ExpoCustomMarker, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement(props) {\n      throw new Error('createLeafletElement should be overwritten');\n    }\n  }, {\n    key: \"getRelativePoint\",\n    value: function getRelativePoint(point) {\n      if (!point) return null;\n\n      var _ofPoint = ofPoint(point),\n          x = _ofPoint.x,\n          y = _ofPoint.y;\n\n      var _this$rect = this.rect,\n          width = _this$rect.width,\n          height = _this$rect.height;\n      return {\n        x: x * width,\n        y: y * height\n      };\n    }\n  }, {\n    key: \"getRelativePointFromRect\",\n    value: function getRelativePointFromRect(point, element) {\n      if (!point) return null;\n\n      var _ofPoint2 = ofPoint(point),\n          x = _ofPoint2.x,\n          y = _ofPoint2.y;\n\n      var width = element.width,\n          height = element.height;\n      return {\n        x: x * width,\n        y: y * height\n      };\n    }\n  }, {\n    key: \"getPopupRelativePointFromRect\",\n    value: function getPopupRelativePointFromRect(point, element) {\n      if (!point) return null;\n\n      var _ofPoint3 = ofPoint(point),\n          x = _ofPoint3.x,\n          y = _ofPoint3.y;\n\n      var width = element.width,\n          height = element.height;\n      return {\n        x: x * width - width / 2,\n        y: y * height - height\n      };\n    }\n  }, {\n    key: \"tryUpdatePopupAnchor\",\n    value: function tryUpdatePopupAnchor(anchor) {\n      var _this6 = this;\n\n      if (!anchor) return;\n      var element = this.leafletElement._popup;\n      clearTimeout(this._popupAnchorTimeout);\n      logger.log('Element', element._container);\n\n      if (!element._container) {\n        this._popupAnchorTimeout = setTimeout(function () {\n          return _this6.tryUpdatePopupAnchor(anchor);\n        }, 300);\n      } else {\n        this.updatePopupAnchor(anchor, element._container);\n      }\n    }\n  }, {\n    key: \"updatePopupAnchor\",\n    value: function updatePopupAnchor(anchor, element) {\n      if (!element) return;\n      var rect = element.getBoundingClientRect();\n\n      var _ofPoint4 = ofPoint(anchor),\n          x = _ofPoint4.x,\n          y = _ofPoint4.y;\n\n      var containerRect = this.rect;\n      var height = rect.height;\n      var computedStyle = window.getComputedStyle(element);\n      var outerHeight = 0;\n      outerHeight += parseInt(computedStyle.marginTop, 10);\n      outerHeight += parseInt(computedStyle.marginBottom, 10);\n      outerHeight += parseInt(computedStyle.borderTopWidth, 10);\n      outerHeight += parseInt(computedStyle.borderBottomWidth, 10);\n      outerHeight *= 0.5;\n      outerHeight += height;\n      var popupAnchor = {\n        x: containerRect.width * -0.5 + containerRect.width * x,\n        y: (y - 1) * outerHeight\n      };\n      this.icon.options.popupAnchor = popupAnchor;\n    }\n  }, {\n    key: \"updateLeafletElement\",\n    value: function updateLeafletElement(fromProps, toProps) {\n      var fromPosition = fromProps.position,\n          fromZIndexOffset = fromProps.zIndexOffset,\n          fromOpacity = fromProps.opacity,\n          fromDraggable = fromProps.draggable,\n          fromClassName = fromProps.className,\n          fromAnchor = fromProps.anchor,\n          fromCalloutAnchor = fromProps.calloutAnchor;\n      var toPosition = toProps.position,\n          toZIndexOffset = toProps.zIndexOffset,\n          toOpacity = toProps.toOpacity,\n          toDraggable = toProps.draggable,\n          toClassName = toProps.className,\n          toAnchor = toProps.anchor,\n          toCalloutAnchor = toProps.calloutAnchor;\n      var rect;\n\n      if (toAnchor !== fromAnchor) {\n        if (!rect) rect = this.getRectWithIcon();\n        this.updateAnchor(toAnchor, rect);\n      }\n\n      if (toCalloutAnchor !== fromCalloutAnchor) {\n        if (!rect) rect = this.getRectWithIcon();\n        this.updateCalloutAnchor(toCalloutAnchor, rect);\n      }\n\n      if (toPosition !== fromPosition) {\n        this.leafletElement.setLatLng(toPosition);\n      }\n\n      if (toZIndexOffset !== fromZIndexOffset) {\n        this.leafletElement.setZIndexOffset(toZIndexOffset);\n      }\n\n      if (toOpacity !== fromOpacity) {\n        this.leafletElement.setOpacity(toOpacity);\n      }\n\n      if (toProps.icon !== fromProps.icon) {\n        this.observeLayout(this.leafletElement.getElement());\n      }\n\n      if (toDraggable !== fromDraggable) {\n        if (toDraggable) {\n          this.leafletElement.dragging.enable();\n        } else {\n          this.leafletElement.dragging.disable();\n        }\n      }\n\n      if (toClassName !== fromClassName) {\n        var _this$leafletElement$, _this$leafletElement$2;\n\n        var fromClasses = fromClassName.split(' ');\n        var toClasses = toClassName.split(' ');\n\n        (_this$leafletElement$ = this.leafletElement.getElement().classList).remove.apply(_this$leafletElement$, _toConsumableArray(difference(fromClasses, toClasses)));\n\n        (_this$leafletElement$2 = this.leafletElement.getElement().classList).add.apply(_this$leafletElement$2, _toConsumableArray(difference(toClasses, fromClasses)));\n      }\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      var _this7 = this;\n\n      if (_get(_getPrototypeOf(ExpoCustomMarker.prototype), \"componentWillMount\", this)) {\n        _get(_getPrototypeOf(ExpoCustomMarker.prototype), \"componentWillMount\", this).call(this);\n      }\n\n      this.leafletElement = this.createLeafletElement(this.props);\n      this.leafletElement.on('add', function () {\n        _this7.forceUpdate(function () {\n          _this7.updateLeafletElement({}, _this7.props);\n\n          _this7.observeLayout(_this7.leafletElement.getElement());\n        });\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(fromProps) {\n      this.updateLeafletElement(fromProps, this.props);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      throw new Error('render should be overwritten');\n    }\n  }, {\n    key: \"icon\",\n    get: function get() {\n      if (!this.leafletElement.options.icon) throw new Error('Leaflet.Marker: icon not loaded yet');\n      return this.leafletElement.options.icon;\n    }\n  }, {\n    key: \"rect\",\n    get: function get() {\n      var element = this.leafletElement.getElement();\n      if (!element) return {};\n      return element.getBoundingClientRect();\n    }\n  }]);\n\n  return ExpoCustomMarker;\n}(MapLayer);\n\nvar ReactDivIcon = function (_ExpoCustomMarker) {\n  _inherits(ReactDivIcon, _ExpoCustomMarker);\n\n  function ReactDivIcon() {\n    _classCallCheck(this, ReactDivIcon);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ReactDivIcon).apply(this, arguments));\n  }\n\n  _createClass(ReactDivIcon, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement(props) {\n      var map = props.map,\n          layerContainer = props.layerContainer,\n          position = props.position,\n          anchor = props.anchor,\n          rest = _objectWithoutProperties(props, [\"map\", \"layerContainer\", \"position\", \"anchor\"]);\n\n      var icon = new DivIcon(_objectSpread({}, rest, {\n        className: '',\n        iconSize: undefined\n      }));\n      var options = this.getOptions(props);\n      var popupContainer = marker(position, _objectSpread({}, options, {\n        icon: icon\n      }));\n      this.contextValue = _objectSpread({}, props.leaflet, {\n        popupContainer: popupContainer\n      });\n      return popupContainer;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          children = _this$props2.children,\n          icon = _this$props2.icon;\n      var container = this.leafletElement.getElement();\n\n      if (!container) {\n        return null;\n      }\n\n      this.portal = createPortal(React.createElement(View, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 486\n        }\n      }, icon && React.createElement(FullSizeImage, {\n        style: [StyleSheet.absoluteFill, {\n          zIndex: -1\n        }],\n        source: {\n          uri: icon.options.iconUrl\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 488\n        }\n      }), children), container);\n      var LeafletProvider = RL.LeafletProvider;\n      return this.portal == null || this.contextValue == null ? null : React.createElement(LeafletProvider, {\n        value: this.contextValue,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 503\n        }\n      }, this.portal);\n    }\n  }]);\n\n  return ReactDivIcon;\n}(ExpoCustomMarker);\n\nvar ReactMarker = function (_ExpoCustomMarker2) {\n  _inherits(ReactMarker, _ExpoCustomMarker2);\n\n  function ReactMarker() {\n    _classCallCheck(this, ReactMarker);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ReactMarker).apply(this, arguments));\n  }\n\n  _createClass(ReactMarker, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement(props) {\n      var el = new LeafletMarker(props.position, this.getOptions(props));\n      this.contextValue = _objectSpread({}, props.leaflet, {\n        popupContainer: el\n      });\n      return el;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      var LeafletProvider = RL.LeafletProvider;\n      var container = this.leafletElement.getElement();\n\n      if (!container) {\n        return null;\n      }\n\n      return children == null || this.contextValue == null ? null : React.createElement(LeafletProvider, {\n        value: this.contextValue,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 526\n        }\n      }, children);\n    }\n  }]);\n\n  return ReactMarker;\n}(ExpoCustomMarker);\n\nvar ExpoStandardIcon = RL.withLeaflet(ReactMarker);\nvar ExpoDivIcon = RL.withLeaflet(ReactDivIcon);\n\nfunction ofPoint(point) {\n  if (!point) return;\n\n  if (Array.isArray(point) && point.length === 2) {\n    return {\n      x: point[0],\n      y: point[1]\n    };\n  }\n\n  if (point.x !== undefined && point.y !== undefined) {\n    return {\n      x: point.x,\n      y: point.y\n    };\n  }\n\n  throw new Error('Leaflet.Marker: Point is unexpected type: ' + point);\n}","map":{"version":3,"sources":["C:/Users/codemaxx/Desktop/iBlood/node_modules/react-native-maps/lib/web/Leaflet/Marker.js"],"names":["React","convertCoordinate","parseIconProps","createLogger","transformPathEvents","createPortal","DivIcon","marker","Marker","LeafletMarker","RL","MapLayer","Popup","difference","logger","ExpoMarker","props","state","position","coordinate","ref","leafletElement","openPopup","closePopup","setState","unsupported","nextProps","identifier","reuseIdentifier","title","description","testID","image","icon","opacity","draggable","flat","tracksViewChanges","tracksInfoWindowChanges","stopPropagation","onSelect","onDeselect","onCalloutPress","pinColor","markerTitle","leafletIcon","markerProps","id","isCustom","children","Children","forEach","child","index","type","name","backgroundColor","width","height","display","borderRadius","borderBottomEndRadius","transform","rotate","borderWidth","borderStyle","borderColor","Component","FullSizeImage","size","img","Image","src","source","uri","onload","PixelRatio","get","style","StandardCallout","fontWeight","defaultProps","centerOffset","calloutOffset","anchor","calloutAnchor","ExpoCustomMarker","updateAnchor","element","getElement","iconAnchor","getRelativePointFromRect","getBoundingClientRect","log","options","marginLeft","x","marginTop","y","updateCalloutAnchor","popupAnchor","getPopupRelativePointFromRect","getIconElement","querySelector","getRectWithIcon","container","rect","iconElement","leftMost","Math","min","rightMost","max","topMost","bottomMost","onLayoutDidUpdate","observeElementLayout","resizeObserver","ResizeObserver","observe","observeLayout","Error","point","ofPoint","_popup","clearTimeout","_popupAnchorTimeout","_container","setTimeout","tryUpdatePopupAnchor","updatePopupAnchor","containerRect","computedStyle","window","getComputedStyle","outerHeight","parseInt","marginBottom","borderTopWidth","borderBottomWidth","fromProps","toProps","fromPosition","fromZIndexOffset","zIndexOffset","fromOpacity","fromDraggable","fromClassName","className","fromAnchor","fromCalloutAnchor","toPosition","toZIndexOffset","toOpacity","toDraggable","toClassName","toAnchor","toCalloutAnchor","setLatLng","setZIndexOffset","setOpacity","dragging","enable","disable","fromClasses","split","toClasses","classList","remove","add","createLeafletElement","on","forceUpdate","updateLeafletElement","ReactDivIcon","map","layerContainer","rest","iconSize","undefined","getOptions","popupContainer","contextValue","leaflet","portal","StyleSheet","absoluteFill","zIndex","iconUrl","LeafletProvider","ReactMarker","el","ExpoStandardIcon","withLeaflet","ExpoDivIcon","Array","isArray","length"],"mappings":"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","sourcesContent":["import * as React from 'react';\r\nimport { View, Image as RNImage, PixelRatio, StyleSheet, Text } from 'react-native';\r\nimport { convertCoordinate } from './utils/coordinates';\r\nimport { parseIconProps } from './utils/icons';\r\nimport createLogger from '../utils/createLogger';\r\nimport { transformPathEvents } from './utils/events';\r\n// Missing:\r\n// zIndexOffset\r\n// attribution\r\n\r\nimport { createPortal } from 'react-dom';\r\nimport { DivIcon, marker, Marker as LeafletMarker } from 'leaflet';\r\n\r\nimport * as RL from 'react-leaflet';\r\nimport { MapLayer, Marker, Popup } from 'react-leaflet';\r\nimport { difference } from 'lodash';\r\n\r\nconst logger = createLogger('Leaflet', 'Marker');\r\n\r\nexport default class ExpoMarker extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      position: convertCoordinate(props.coordinate),\r\n    };\r\n  }\r\n  // Shows the callout for this marker\r\n  showCallout() {\r\n    this.ref.leafletElement.openPopup();\r\n  }\r\n  // Hides the callout for this marker\r\n  hideCallout() {\r\n    this.ref.leafletElement.closePopup();\r\n  }\r\n  // // Causes a redraw of the marker's callout. Useful for Google Maps on iOS.\r\n  // // Note: iOS only.\r\n  // redrawCallout() {\r\n  //   logger.warn('redrawCallout() is unsupported');\r\n  // }\r\n  // // Animates marker movement.\r\n  // // Note: Android only\r\n  // animateMarkerToCoordinate(coordinate, duration) {\r\n  //   logger.warn('animateMarkerToCoordinate(coordinate, duration) is unsupported');\r\n  // }\r\n  // // Causes a redraw of the marker. Useful when there are updates to the marker and tracksViewChanges comes with a cost that is too high.\r\n  // redraw() {\r\n  //   logger.warn('redraw() is unsupported');\r\n  // }\r\n\r\n  setNativeProps({ coordinate, ...props }) {\r\n    if (coordinate) {\r\n      this.setState({ position: convertCoordinate(coordinate) });\r\n    }\r\n    logger.unsupported(props);\r\n  }\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    if (nextProps.coordinate !== this.props.coordinate) {\r\n      this.setState({ position: convertCoordinate(nextProps.coordinate) });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      identifier,\r\n      reuseIdentifier,\r\n      title,\r\n      description,\r\n      testID,\r\n      image,\r\n      icon,\r\n      opacity,\r\n      coordinate,\r\n      draggable,\r\n      flat,\r\n      tracksViewChanges,\r\n      tracksInfoWindowChanges,\r\n      stopPropagation,\r\n      onSelect,\r\n      onDeselect,\r\n      onCalloutPress,\r\n      pinColor,\r\n      ...props\r\n    } = this.props;\r\n    const markerTitle = description ? `${title}\\n${description}` : title;\r\n    const { position } = this.state;\r\n    let leafletIcon = parseIconProps({ icon, image, ...props }); // TODO:\r\n\r\n    const markerProps = {\r\n      ...props,\r\n      ...transformPathEvents(props),\r\n      id: identifier,\r\n      opacity,\r\n      draggable,\r\n      title: markerTitle,\r\n      position,\r\n    };\r\n\r\n    let isCustom = false;\r\n\r\n    if (leafletIcon) {\r\n      isCustom = true;\r\n      markerProps.icon = leafletIcon;\r\n    }\r\n\r\n    if (!isCustom && props.children) {\r\n      React.Children.forEach(props.children, (child, index) => {\r\n        if (!isCustom && child.type.name !== 'MapCallout') {\r\n          isCustom = true;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (isCustom) {\r\n      return <ExpoDivIcon ref={ref => (this.ref = ref)} {...markerProps} />;\r\n    } else if (pinColor) {\r\n      return (\r\n        <ExpoDivIcon ref={ref => (this.ref = ref)} {...markerProps}>\r\n          <View\r\n            style={{\r\n              backgroundColor: pinColor,\r\n              width: '3rem',\r\n              height: '3rem',\r\n              display: 'block',\r\n              position: 'relative',\r\n              borderRadius: '3rem',\r\n              borderBottomEndRadius: 0,\r\n              transform: [{ rotate: '45deg' }],\r\n              borderWidth: 1,\r\n              borderStyle: 'solid',\r\n              borderColor: '#fff',\r\n            }}\r\n          />\r\n          {markerProps.children}\r\n          <StandardCallout title={title} description={description} />\r\n        </ExpoDivIcon>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <ExpoStandardIcon ref={ref => (this.ref = ref)} {...markerProps}>\r\n        {markerProps.children}\r\n        {(title || description) && <StandardCallout title={title} description={description} />}\r\n      </ExpoStandardIcon>\r\n    );\r\n  }\r\n}\r\n\r\nclass FullSizeImage extends React.Component {\r\n  state = {\r\n    size: {},\r\n  };\r\n\r\n  componentDidMount() {\r\n    const img = new Image();\r\n    img.src = this.props.source.uri ? this.props.source.uri : this.props.source;\r\n    img.onload = () => {\r\n      this.setState({\r\n        size: {\r\n          width: img.width / PixelRatio.get(),\r\n          height: img.height / PixelRatio.get(),\r\n        },\r\n      });\r\n    };\r\n  }\r\n  render() {\r\n    return (\r\n      <RNImage\r\n        testID=\"expo-maps-marker-full-size-image\"\r\n        {...this.props}\r\n        style={[this.props.style, this.state.size]}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\n// function FullSizeImage({ source, ...props }) {\r\n//   const [size, setSize] = React.useState({});\r\n\r\n//   React.useEffect(() => {\r\n//     const img = new HTMLImageElement();\r\n//     img.src = source.uri ? source.uri : source;\r\n//     img.onload = () => {\r\n//       setSize({\r\n//         width: img.width,\r\n//         height: img.height,\r\n//       });\r\n//     };\r\n//     return () => (img = null);\r\n//   }, [source]);\r\n\r\n//   return <Image {...props} style={[props.style, size]} />;\r\n// }\r\n\r\nfunction StandardCallout({ title, description }) {\r\n  return (\r\n    <Popup>\r\n      <View>\r\n        {title && <Text style={{ fontWeight: 'bold' }}>{title}</Text>}\r\n        {description && <Text>{description}</Text>}\r\n      </View>\r\n    </Popup>\r\n  );\r\n}\r\n\r\nExpoMarker.defaultProps = {\r\n  centerOffset: /** Unused: use `anchor` instead */ null,\r\n  calloutOffset: /** Unused: use `calloutAnchor` instead */ null,\r\n  anchor: /** Leeaflet: `iconAnchor` */ [0.5, 1],\r\n  calloutAnchor: /** Leaflet: `popupAnchor` */ [0.5, 0],\r\n  // flat: /** Unsupported */ false,\r\n  // rotation: /** Unsupported */ 0,\r\n  // tracksViewChanges: /** Unused */ true,\r\n  // tracksInfoWindowChanges: /** Unused */ false,\r\n  stopPropagation: /** Unimplemented */ false,\r\n  draggable: false,\r\n  opacity: 1.0,\r\n};\r\n\r\n// TODO(Bacon): Update the anchor when the layout changes\r\n// https://stackoverflow.com/questions/47018368/implementing-a-dynamic-jsx-element-within-a-marker-using-react-leaflet/54504646#54504646\r\nclass ExpoCustomMarker extends MapLayer {\r\n  createLeafletElement(props) {\r\n    throw new Error('createLeafletElement should be overwritten');\r\n  }\r\n\r\n  getRelativePoint(point) {\r\n    if (!point) return null;\r\n    const { x, y } = ofPoint(point);\r\n    const { width, height } = this.rect;\r\n    return { x: x * width, y: y * height };\r\n  }\r\n\r\n  getRelativePointFromRect(point, element) {\r\n    if (!point) return null;\r\n    const { x, y } = ofPoint(point);\r\n    const { width, height } = element;\r\n    return { x: x * width, y: y * height };\r\n  }\r\n\r\n  getPopupRelativePointFromRect(point, element) {\r\n    if (!point) return null;\r\n    const { x, y } = ofPoint(point);\r\n    const { width, height } = element;\r\n    return { x: x * width - width / 2, y: y * height - height };\r\n  }\r\n\r\n  get icon() {\r\n    if (!this.leafletElement.options.icon) throw new Error('Leaflet.Marker: icon not loaded yet');\r\n\r\n    return this.leafletElement.options.icon;\r\n  }\r\n\r\n  get rect() {\r\n    const element = this.leafletElement.getElement();\r\n    if (!element) return {};\r\n    return element.getBoundingClientRect();\r\n  }\r\n\r\n  tryUpdatePopupAnchor(anchor) {\r\n    if (!anchor) return;\r\n\r\n    const element = this.leafletElement._popup;\r\n\r\n    clearTimeout(this._popupAnchorTimeout);\r\n    logger.log('Element', element._container);\r\n    if (!element._container) {\r\n      this._popupAnchorTimeout = setTimeout(() => this.tryUpdatePopupAnchor(anchor), 300);\r\n    } else {\r\n      this.updatePopupAnchor(anchor, element._container);\r\n    }\r\n  }\r\n\r\n  updatePopupAnchor(anchor, element) {\r\n    if (!element) return;\r\n\r\n    const rect = element.getBoundingClientRect();\r\n    const { x, y } = ofPoint(anchor);\r\n    const containerRect = this.rect;\r\n    const { height } = rect;\r\n\r\n    const computedStyle = window.getComputedStyle(element);\r\n    let outerHeight = 0;\r\n    outerHeight += parseInt(computedStyle.marginTop, 10);\r\n    outerHeight += parseInt(computedStyle.marginBottom, 10);\r\n    outerHeight += parseInt(computedStyle.borderTopWidth, 10);\r\n    outerHeight += parseInt(computedStyle.borderBottomWidth, 10);\r\n    outerHeight *= 0.5;\r\n    outerHeight += height;\r\n\r\n    const popupAnchor = {\r\n      x: containerRect.width * -0.5 + containerRect.width * x,\r\n      y: (y - 1) * outerHeight,\r\n    };\r\n\r\n    // logger.log('RECT: ', rect, element, element.style, outerHeight, popupAnchor);\r\n    // Update the option for internal usage\r\n    this.icon.options.popupAnchor = popupAnchor;\r\n  }\r\n\r\n  updateAnchor = (anchor, element) => {\r\n    if (!this.leafletElement.getElement()) return;\r\n    // Convert to a unified format\r\n    const iconAnchor = this.getRelativePointFromRect(\r\n      anchor,\r\n      element || this.leafletElement.getElement().getBoundingClientRect()\r\n    );\r\n    logger.log('toAnchor: ', iconAnchor, this.leafletElement.getElement().getBoundingClientRect());\r\n    // Update the option for internal usage\r\n    this.icon.options.iconAnchor = iconAnchor;\r\n    // Manually redefine the styles\r\n    this.leafletElement.getElement().style.marginLeft = -iconAnchor.x + 'px';\r\n    this.leafletElement.getElement().style.marginTop = -iconAnchor.y + 'px';\r\n  };\r\n\r\n  updateCalloutAnchor = (anchor, element) => {\r\n    if (!this.leafletElement.getElement()) return;\r\n    // TODO(Bacon): Experimental: this feature requires the callout to be rendered before it can correctly position the element.\r\n    // this.tryUpdatePopupAnchor(anchor);\r\n    this.icon.options.popupAnchor = this.getPopupRelativePointFromRect(\r\n      anchor,\r\n      element || this.leafletElement.getElement().getBoundingClientRect()\r\n    );\r\n  };\r\n\r\n  updateLeafletElement(fromProps, toProps) {\r\n    const {\r\n      position: fromPosition,\r\n      zIndexOffset: fromZIndexOffset,\r\n      opacity: fromOpacity,\r\n      draggable: fromDraggable,\r\n      className: fromClassName,\r\n      anchor: fromAnchor,\r\n      calloutAnchor: fromCalloutAnchor,\r\n    } = fromProps;\r\n    const {\r\n      position: toPosition,\r\n      zIndexOffset: toZIndexOffset,\r\n      toOpacity,\r\n      draggable: toDraggable,\r\n      className: toClassName,\r\n      anchor: toAnchor,\r\n      calloutAnchor: toCalloutAnchor,\r\n    } = toProps;\r\n\r\n    // this.icon.options.iconSize = [this.rect.width, this.rect.height];\r\n\r\n    let rect;\r\n    if (toAnchor !== fromAnchor) {\r\n      if (!rect) rect = this.getRectWithIcon();\r\n      this.updateAnchor(toAnchor, rect);\r\n    }\r\n\r\n    if (toCalloutAnchor !== fromCalloutAnchor) {\r\n      if (!rect) rect = this.getRectWithIcon();\r\n      this.updateCalloutAnchor(toCalloutAnchor, rect);\r\n    }\r\n\r\n    if (toPosition !== fromPosition) {\r\n      this.leafletElement.setLatLng(toPosition);\r\n    }\r\n    if (toZIndexOffset !== fromZIndexOffset) {\r\n      this.leafletElement.setZIndexOffset(toZIndexOffset);\r\n    }\r\n    if (toOpacity !== fromOpacity) {\r\n      this.leafletElement.setOpacity(toOpacity);\r\n    }\r\n    if (toProps.icon !== fromProps.icon) {\r\n      // this.leafletElement.setIcon(toProps.icon);\r\n      this.observeLayout(this.leafletElement.getElement());\r\n    }\r\n    if (toDraggable !== fromDraggable) {\r\n      if (toDraggable) {\r\n        this.leafletElement.dragging.enable();\r\n      } else {\r\n        this.leafletElement.dragging.disable();\r\n      }\r\n    }\r\n    if (toClassName !== fromClassName) {\r\n      const fromClasses = fromClassName.split(' ');\r\n      const toClasses = toClassName.split(' ');\r\n      this.leafletElement.getElement().classList.remove(...difference(fromClasses, toClasses));\r\n      this.leafletElement.getElement().classList.add(...difference(toClasses, fromClasses));\r\n    }\r\n  }\r\n\r\n  componentWillMount() {\r\n    if (super.componentWillMount) {\r\n      super.componentWillMount();\r\n    }\r\n    this.leafletElement = this.createLeafletElement(this.props);\r\n    this.leafletElement.on('add', () => {\r\n      this.forceUpdate(() => {\r\n        // Wait until the React elements have rendered before setting things like anchor which require the bounding rect.\r\n        this.updateLeafletElement({}, this.props);\r\n        this.observeLayout(this.leafletElement.getElement());\r\n      });\r\n    });\r\n  }\r\n\r\n  componentDidUpdate(fromProps) {\r\n    this.updateLeafletElement(fromProps, this.props);\r\n  }\r\n\r\n  getIconElement = () => {\r\n    const element = this.leafletElement.getElement();\r\n    if (!element) return null;\r\n    return element.querySelector('[data-testid=\"expo-maps-marker-full-size-image\"]');\r\n  };\r\n\r\n  getRectWithIcon = () => {\r\n    const container = this.rect;\r\n    const iconElement = this.getIconElement();\r\n    if (!iconElement) return this.rect;\r\n    const icon = iconElement.getBoundingClientRect();\r\n\r\n    const leftMost = Math.min(icon.x, container.x);\r\n    const rightMost = Math.max(icon.x + icon.width, container.x + container.width);\r\n    const topMost = Math.min(icon.y, container.y);\r\n    const bottomMost = Math.max(icon.y + icon.height, container.y + container.height);\r\n    return {\r\n      width: rightMost - leftMost,\r\n      height: bottomMost - topMost,\r\n    };\r\n  };\r\n\r\n  onLayoutDidUpdate = () => {\r\n    const rect = this.getRectWithIcon();\r\n    this.updateAnchor(this.props.anchor, rect);\r\n    this.updateCalloutAnchor(this.props.calloutAnchor, rect);\r\n  };\r\n\r\n  observeElementLayout = element => {\r\n    const resizeObserver = new ResizeObserver(() => {\r\n      this.onLayoutDidUpdate();\r\n    }, element);\r\n    resizeObserver.observe(element);\r\n    return resizeObserver;\r\n  };\r\n\r\n  observeLayout = container => {\r\n    if (!this.resizeObserver) {\r\n      this.resizeObserver = this.observeElementLayout(container);\r\n    }\r\n\r\n    const image = container.querySelector('[data-testid=\"expo-maps-marker-full-size-image\"]');\r\n    if (image) {\r\n      this.observeElementLayout(image);\r\n    }\r\n  };\r\n\r\n  render() {\r\n    throw new Error('render should be overwritten');\r\n  }\r\n}\r\nclass ReactDivIcon extends ExpoCustomMarker {\r\n  createLeafletElement(props) {\r\n    const { map, layerContainer, position, anchor, ...rest } = props;\r\n\r\n    const icon = new DivIcon({\r\n      ...rest,\r\n      className: '',\r\n      iconSize: undefined,\r\n    });\r\n\r\n    const options = this.getOptions(props);\r\n\r\n    const popupContainer = marker(position, {\r\n      ...options,\r\n      icon,\r\n    });\r\n    this.contextValue = { ...props.leaflet, popupContainer };\r\n\r\n    return popupContainer;\r\n  }\r\n\r\n  render() {\r\n    const { children, icon } = this.props;\r\n    const container = this.leafletElement.getElement();\r\n    if (!container) {\r\n      return null;\r\n    }\r\n\r\n    this.portal = createPortal(\r\n      <View>\r\n        {icon && (\r\n          <FullSizeImage\r\n            style={[StyleSheet.absoluteFill, { zIndex: -1 }]}\r\n            source={{ uri: icon.options.iconUrl }}\r\n          />\r\n        )}\r\n        {children}\r\n      </View>,\r\n      container\r\n    );\r\n\r\n    const { LeafletProvider } = RL;\r\n\r\n    // this.observeLayout(container);\r\n\r\n    return this.portal == null || this.contextValue == null ? null : (\r\n      <LeafletProvider value={this.contextValue}>{this.portal}</LeafletProvider>\r\n    );\r\n  }\r\n}\r\n\r\nclass ReactMarker extends ExpoCustomMarker {\r\n  createLeafletElement(props) {\r\n    const el = new LeafletMarker(props.position, this.getOptions(props));\r\n    this.contextValue = { ...props.leaflet, popupContainer: el };\r\n    return el;\r\n  }\r\n\r\n  render() {\r\n    const { children } = this.props;\r\n\r\n    const { LeafletProvider } = RL;\r\n\r\n    const container = this.leafletElement.getElement();\r\n    if (!container) {\r\n      return null;\r\n    }\r\n    // this.observeLayout(container);\r\n    return children == null || this.contextValue == null ? null : (\r\n      <LeafletProvider value={this.contextValue}>{children}</LeafletProvider>\r\n    );\r\n  }\r\n}\r\n\r\nconst ExpoStandardIcon = RL.withLeaflet(ReactMarker);\r\n\r\nconst ExpoDivIcon = RL.withLeaflet(ReactDivIcon);\r\n\r\nfunction ofPoint(point) {\r\n  if (!point) return;\r\n\r\n  if (Array.isArray(point) && point.length === 2) {\r\n    return { x: point[0], y: point[1] };\r\n  }\r\n  if (point.x !== undefined && point.y !== undefined) {\r\n    return { x: point.x, y: point.y };\r\n  }\r\n  throw new Error('Leaflet.Marker: Point is unexpected type: ' + point);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}