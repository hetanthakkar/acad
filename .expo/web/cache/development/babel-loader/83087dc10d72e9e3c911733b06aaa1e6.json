{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nvar _jsxFileName = \"C:\\\\Users\\\\codemaxx\\\\Desktop\\\\iBlood\\\\utils\\\\storage.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport AsyncStorage from \"react-native-web/dist/exports/AsyncStorage\";\nimport { EventEmitter } from 'fbemitter';\nimport _ from 'lodash';\n\nvar _emitter = new EventEmitter();\n\nvar _savedTalksStorageKey = '@Nodevember:savedTalks';\n\nvar _savedTalks;\n\nexport var loadSavedTalksAsync = function loadSavedTalksAsync() {\n  var result;\n  return _regeneratorRuntime.async(function loadSavedTalksAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(AsyncStorage.getItem(_savedTalksStorageKey));\n\n        case 3:\n          result = _context.sent;\n\n          if (result) {\n            _savedTalks = JSON.parse(result);\n          }\n\n          _context.next = 10;\n          break;\n\n        case 7:\n          _context.prev = 7;\n          _context.t0 = _context[\"catch\"](0);\n          console.warn(_context.t0);\n\n        case 10:\n          _context.prev = 10;\n\n          if (!_savedTalks) {\n            _savedTalks = {};\n          }\n\n          return _context.finish(10);\n\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[0, 7, 10, 13]], Promise);\n};\nexport function getSavedStateForTalk(talk) {\n  var talkKey = _.snakeCase(talk.title);\n\n  var active = _savedTalks[talkKey];\n  return active;\n}\nexport function subscribeToUpdates(talk, onUpdateFn) {\n  var talkKey = _.snakeCase(talk.title);\n\n  return _emitter.addListener('change', function () {\n    var active = _savedTalks[talkKey];\n    onUpdateFn(active);\n  });\n}\nexport var toggleSaved = function toggleSaved(talk) {\n  var key = _.snakeCase(talk.title);\n\n  var newSavedTalks = _objectSpread(_objectSpread({}, _savedTalks), {}, _defineProperty({}, key, !_savedTalks[key]));\n\n  _updateSavedTalks(newSavedTalks);\n};\n\nfunction _updateSavedTalks(savedTalks) {\n  _savedTalks = savedTalks;\n\n  _emitter.emit('change');\n\n  _updateAsyncStorage();\n}\n\nfunction _updateAsyncStorage() {\n  try {\n    AsyncStorage.setItem(_savedTalksStorageKey, JSON.stringify(_savedTalks));\n  } catch (e) {\n    console.warn(e);\n  }\n}\n\nexport function withSaveState(WrappedComponent) {\n  var ComponentWithSaveState = function (_React$Component) {\n    _inherits(ComponentWithSaveState, _React$Component);\n\n    var _super = _createSuper(ComponentWithSaveState);\n\n    function ComponentWithSaveState() {\n      var _this;\n\n      _classCallCheck(this, ComponentWithSaveState);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this.state = {\n        saved: getSavedStateForTalk(_this.props.talk)\n      };\n      return _this;\n    }\n\n    _createClass(ComponentWithSaveState, [{\n      key: \"componentWillMount\",\n      value: function componentWillMount() {\n        var _this2 = this;\n\n        this._subscription = subscribeToUpdates(this.props.talk, function (saved) {\n          if (saved !== _this2.state.saved) {\n            _this2.setState({\n              saved: saved\n            });\n          }\n        });\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._subscription.remove();\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return React.createElement(WrappedComponent, _extends({\n          saved: this.state.saved\n        }, this.props, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 83,\n            columnNumber: 14\n          }\n        }));\n      }\n    }]);\n\n    return ComponentWithSaveState;\n  }(React.Component);\n\n  return ComponentWithSaveState;\n}\nexport function saveNewContact(contact, navigation) {\n  AsyncStorage.getItem('@MySuperStore2019:contacts').then(function (storedContacts) {\n    var contacts = null;\n    var newContacts = [];\n    var found = false;\n\n    if (storedContacts === null && contact && contact.firstName) {\n      contacts = [contact];\n    } else {\n      var existingContacts = JSON.parse(storedContacts) || [];\n      console.log('how many existing contacts', existingContacts.length);\n      existingContacts.map(function (existingContact) {\n        console.log('existing contact', existingContact);\n\n        if (existingContact && existingContact.id && contact && contact.id && existingContact.id === contact.id) {\n          found = true;\n          newContacts.push(contact);\n        } else if (existingContact && existingContact.id) {\n          newContacts.push(existingContact);\n        }\n      });\n\n      if (!found && contact && contact.id) {\n        newContacts.push(contact);\n      }\n\n      contacts = newContacts;\n    }\n\n    if (contacts === [null]) {\n      contacts = [];\n    }\n\n    var stringifiedContacts = JSON.stringify(contacts);\n    AsyncStorage.setItem('@MySuperStore2019:contacts', stringifiedContacts).then(function () {\n      navigation.navigate('Contacts');\n    });\n  });\n}","map":{"version":3,"sources":["C:/Users/codemaxx/Desktop/iBlood/utils/storage.js"],"names":["React","EventEmitter","_","_emitter","_savedTalksStorageKey","_savedTalks","loadSavedTalksAsync","AsyncStorage","getItem","result","JSON","parse","console","warn","getSavedStateForTalk","talk","talkKey","snakeCase","title","active","subscribeToUpdates","onUpdateFn","addListener","toggleSaved","key","newSavedTalks","_updateSavedTalks","savedTalks","emit","_updateAsyncStorage","setItem","stringify","e","withSaveState","WrappedComponent","ComponentWithSaveState","state","saved","props","_subscription","setState","remove","Component","saveNewContact","contact","navigation","then","storedContacts","contacts","newContacts","found","firstName","existingContacts","log","length","map","existingContact","id","push","stringifiedContacts","navigate"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport {AsyncStorage} from 'react-native';\r\nimport {EventEmitter} from 'fbemitter';\r\nimport _ from 'lodash';\r\n\r\nconst _emitter = new EventEmitter();\r\nconst _savedTalksStorageKey = '@Nodevember:savedTalks';\r\nlet _savedTalks;\r\n\r\nexport const loadSavedTalksAsync = async () => {\r\n  try {\r\n    let result = await AsyncStorage.getItem(_savedTalksStorageKey);\r\n    if (result) {\r\n      _savedTalks = JSON.parse(result);\r\n    }\r\n  } catch (e) {\r\n    console.warn(e);\r\n  } finally {\r\n    if (!_savedTalks) {\r\n      _savedTalks = {};\r\n    }\r\n  }\r\n};\r\n\r\nexport function getSavedStateForTalk(talk) {\r\n  const talkKey = _.snakeCase(talk.title);\r\n  const active = _savedTalks[talkKey];\r\n  return active;\r\n}\r\n\r\n// Returns the subscription, subscriber needs to remove subscription on unmount\r\nexport function subscribeToUpdates(talk, onUpdateFn) {\r\n  const talkKey = _.snakeCase(talk.title);\r\n  return _emitter.addListener('change', () => {\r\n    const active = _savedTalks[talkKey];\r\n    onUpdateFn(active);\r\n  });\r\n}\r\n\r\nexport const toggleSaved = talk => {\r\n  let key = _.snakeCase(talk.title);\r\n  let newSavedTalks = {\r\n    ..._savedTalks,\r\n    [key]: !_savedTalks[key],\r\n  };\r\n\r\n  _updateSavedTalks(newSavedTalks);\r\n};\r\n\r\nfunction _updateSavedTalks(savedTalks) {\r\n  _savedTalks = savedTalks;\r\n  _emitter.emit('change');\r\n  _updateAsyncStorage();\r\n}\r\n\r\nfunction _updateAsyncStorage() {\r\n  try {\r\n    AsyncStorage.setItem(_savedTalksStorageKey, JSON.stringify(_savedTalks));\r\n  } catch (e) {\r\n    console.warn(e);\r\n  }\r\n}\r\n\r\nexport function withSaveState(WrappedComponent) {\r\n  class ComponentWithSaveState extends React.Component {\r\n    state = {\r\n      saved: getSavedStateForTalk(this.props.talk),\r\n    };\r\n\r\n    componentWillMount() {\r\n      this._subscription = subscribeToUpdates(this.props.talk, saved => {\r\n        if (saved !== this.state.saved) {\r\n          this.setState({saved});\r\n        }\r\n      });\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      this._subscription.remove();\r\n    }\r\n\r\n    render() {\r\n      return <WrappedComponent saved={this.state.saved} {...this.props} />;\r\n    }\r\n  }\r\n\r\n  return ComponentWithSaveState;\r\n}\r\n\r\nexport function saveNewContact(contact, navigation) {\r\n  AsyncStorage.getItem('@MySuperStore2019:contacts').then(storedContacts => {\r\n    let contacts = null;\r\n    let newContacts = [];\r\n    let found = false;\r\n    if (storedContacts === null && contact && contact.firstName) {\r\n      contacts = [contact];\r\n    } else {\r\n      let existingContacts = JSON.parse(storedContacts) || [];\r\n      console.log('how many existing contacts', existingContacts.length);\r\n      existingContacts.map(existingContact => {\r\n        console.log('existing contact', existingContact);\r\n        if (\r\n          existingContact &&\r\n          existingContact.id &&\r\n          contact &&\r\n          contact.id &&\r\n          existingContact.id === contact.id\r\n        ) {\r\n          found = true;\r\n          newContacts.push(contact);\r\n        } else if (existingContact && existingContact.id) {\r\n          newContacts.push(existingContact);\r\n        }\r\n      });\r\n      if (!found && contact && contact.id) {\r\n        newContacts.push(contact);\r\n      }\r\n      contacts = newContacts;\r\n    }\r\n    if (contacts === [null]) {\r\n      contacts = [];\r\n    }\r\n    let stringifiedContacts = JSON.stringify(contacts);\r\n    AsyncStorage.setItem('@MySuperStore2019:contacts', stringifiedContacts)\r\n      //AsyncStorage.removeItem('@MySuperStore2019:tickets')\r\n      .then(() => {\r\n        navigation.navigate('Contacts');\r\n      });\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}