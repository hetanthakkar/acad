{"ast":null,"code":"export default function blockPlugin(md, name, options) {\n  function validateDefault(params) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, self) {\n    return self.renderToken(tokens, idx, _options, env, self);\n  }\n\n  options = options || {};\n  var min_markers = 1;\n  var marker_str = options.marker || \"[\" + name + \"]\";\n  var marker_end_str = options.marker_end || \"[/\" + name + \"]\";\n  var marker_char = marker_str.charCodeAt(0);\n  var marker_len = marker_str.length;\n  var marker_end_len = marker_end_str.length;\n  var validate = options.validate || validateDefault;\n  var render = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos,\n        nextLine,\n        marker_count,\n        markup,\n        params,\n        token,\n        old_parent,\n        old_line_max,\n        auto_closed = false,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine];\n\n    if (marker_char !== state.src.charCodeAt(start)) {\n      return false;\n    }\n\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n\n    if (marker_count < min_markers) {\n      return false;\n    }\n\n    pos -= (pos - start) % marker_len;\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n\n    if (silent) {\n      return true;\n    }\n\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n\n      if (nextLine >= endLine) {\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_end_str[(pos - start) % marker_end_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      if (Math.floor((pos - start) / marker_end_len) < marker_count) {\n        continue;\n      }\n\n      pos -= (pos - start) % marker_end_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) {\n        continue;\n      }\n\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n    state.lineMax = nextLine;\n    token = state.push(\"container_\" + name + \"_open\", name, 1);\n    token.markup = markup;\n    token.block = true;\n    token.info = params;\n    token.map = [startLine, nextLine];\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n    token = state.push(\"container_\" + name + \"_close\", name, -1);\n    token.markup = state.src.slice(start, pos);\n    token.block = true;\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_checklist', container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n}","map":{"version":3,"sources":["C:/Users/codemaxx/Desktop/iBlood/node_modules/react-native-markdown-renderer/src/lib/plugin/blockPlugin.js"],"names":["blockPlugin","md","name","options","validateDefault","params","trim","split","renderDefault","tokens","idx","_options","env","self","renderToken","min_markers","marker_str","marker","marker_end_str","marker_end","marker_char","charCodeAt","marker_len","length","marker_end_len","validate","render","container","state","startLine","endLine","silent","pos","nextLine","marker_count","markup","token","old_parent","old_line_max","auto_closed","start","bMarks","tShift","max","eMarks","src","Math","floor","slice","sCount","blkIndent","skipSpaces","parentType","lineMax","push","block","info","map","tokenize","line","ruler","before","alt","renderer","rules"],"mappings":"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","sourcesContent":["/* code is still in beta, thats why im disabling linter */\n/* eslint-disable */\n\n/**\n * How to use?\n *  new PluginContainer(blockPlugin, '__name_of_block__', {})\n * @param md\n * @param name\n * @param options\n */\nexport default function blockPlugin(md, name, options) {\n  function validateDefault(params) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n\n  function renderDefault(tokens, idx, _options, env, self) {\n    return self.renderToken(tokens, idx, _options, env, self);\n  }\n\n  options = options || {};\n\n  let min_markers = 1;\n  let marker_str = options.marker || `[${name}]`;\n  let marker_end_str = options.marker_end || `[/${name}]`;\n  let marker_char = marker_str.charCodeAt(0);\n  let marker_len = marker_str.length;\n  let marker_end_len = marker_end_str.length;\n\n  let validate = options.validate || validateDefault;\n  let render = options.render || renderDefault;\n\n  function container(state, startLine, endLine, silent) {\n    var pos,\n      nextLine,\n      marker_count,\n      markup,\n      params,\n      token,\n      old_parent,\n      old_line_max,\n      auto_closed = false,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) {\n      return false;\n    }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n\n    marker_count = Math.floor((pos - start) / marker_len);\n    if (marker_count < min_markers) {\n      return false;\n    }\n    pos -= (pos - start) % marker_len;\n\n    markup = state.src.slice(start, pos);\n    params = state.src.slice(pos, max);\n\n    // if (!validate(params)) {\n    //   return false;\n    // }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) {\n      return true;\n    }\n\n    // Search for the end of the block\n    //\n    nextLine = startLine;\n\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_end_str[(pos - start) % marker_end_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_end_len) < marker_count) {\n        continue;\n      }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_end_len;\n      pos = state.skipSpaces(pos);\n\n      if (pos < max) {\n        continue;\n      }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n\n    old_parent = state.parentType;\n    old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    token = state.push(`container_${name}_open`, name, 1);\n    token.markup = markup;\n    token.block = true;\n    token.info = params;\n    token.map = [startLine, nextLine];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    token = state.push(`container_${name}_close`, name, -1);\n    token.markup = state.src.slice(start, pos);\n    token.block = true;\n\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n\n    return true;\n  }\n\n  md.block.ruler.before('fence', 'container_checklist', container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list'],\n  });\n\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n}\n"]},"metadata":{},"sourceType":"module"}