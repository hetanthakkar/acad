{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport getUniqueID from \"./getUniqueID\";\nimport getTokenTypeByToken from \"./getTokenTypeByToken\";\n\nfunction createNode(token, tokenIndex) {\n  var type = getTokenTypeByToken(token);\n  var content = token.content;\n  var attributes = {};\n\n  if (token.attrs) {\n    attributes = token.attrs.reduce(function (prev, curr) {\n      var _curr = _slicedToArray(curr, 2),\n          name = _curr[0],\n          value = _curr[1];\n\n      return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, name, value));\n    }, {});\n  }\n\n  return {\n    type: type,\n    sourceType: token.type,\n    sourceInfo: token.info,\n    sourceMeta: token.meta,\n    block: token.block,\n    key: getUniqueID(),\n    content: content,\n    tokenIndex: tokenIndex,\n    index: 0,\n    attributes: attributes,\n    children: tokensToAST(token.children)\n  };\n}\n\nexport default function tokensToAST(tokens) {\n  var stack = [];\n  var children = [];\n\n  if (!tokens || tokens.length === 0) {\n    return [];\n  }\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n    var astNode = createNode(token, i);\n\n    if (!(astNode.type === 'text' && astNode.children.length === 0 && astNode.content === '')) {\n      astNode.index = children.length;\n\n      if (token.nesting === 1) {\n        children.push(astNode);\n        stack.push(children);\n        children = astNode.children;\n      } else if (token.nesting === -1) {\n        children = stack.pop();\n      } else if (token.nesting === 0) {\n        children.push(astNode);\n      }\n    }\n  }\n\n  return children;\n}","map":{"version":3,"sources":["C:/Users/codemaxx/Desktop/iBlood/node_modules/react-native-markdown-renderer/src/lib/util/tokensToAST.js"],"names":["getUniqueID","getTokenTypeByToken","createNode","token","tokenIndex","type","content","attributes","attrs","reduce","prev","curr","name","value","sourceType","sourceInfo","info","sourceMeta","meta","block","key","index","children","tokensToAST","tokens","stack","length","i","astNode","nesting","push","pop"],"mappings":";;;;;;;AAAA,OAAOA,WAAP;AACA,OAAOC,mBAAP;;AAQA,SAASC,UAAT,CAAoBC,KAApB,EAA2BC,UAA3B,EAAuC;AACrC,MAAMC,IAAI,GAAGJ,mBAAmB,CAACE,KAAD,CAAhC;AACA,MAAMG,OAAO,GAAGH,KAAK,CAACG,OAAtB;AAEA,MAAIC,UAAU,GAAG,EAAjB;;AAEA,MAAIJ,KAAK,CAACK,KAAV,EAAiB;AACfD,IAAAA,UAAU,GAAGJ,KAAK,CAACK,KAAN,CAAYC,MAAZ,CAAmB,UAACC,IAAD,EAAOC,IAAP,EAAgB;AAAA,iCACxBA,IADwB;AAAA,UACvCC,IADuC;AAAA,UACjCC,KADiC;;AAE9C,6CAAYH,IAAZ,2BAAmBE,IAAnB,EAA0BC,KAA1B;AACD,KAHY,EAGV,EAHU,CAAb;AAID;;AAED,SAAO;AACLR,IAAAA,IAAI,EAAJA,IADK;AAELS,IAAAA,UAAU,EAAEX,KAAK,CAACE,IAFb;AAGLU,IAAAA,UAAU,EAAEZ,KAAK,CAACa,IAHb;AAILC,IAAAA,UAAU,EAAEd,KAAK,CAACe,IAJb;AAKLC,IAAAA,KAAK,EAAEhB,KAAK,CAACgB,KALR;AAMLC,IAAAA,GAAG,EAAEpB,WAAW,EANX;AAOLM,IAAAA,OAAO,EAAPA,OAPK;AAQLF,IAAAA,UAAU,EAAVA,UARK;AASLiB,IAAAA,KAAK,EAAE,CATF;AAULd,IAAAA,UAAU,EAAVA,UAVK;AAWLe,IAAAA,QAAQ,EAAEC,WAAW,CAACpB,KAAK,CAACmB,QAAP;AAXhB,GAAP;AAaD;;AAOD,eAAe,SAASC,WAAT,CAAqBC,MAArB,EAA6B;AAC1C,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIH,QAAQ,GAAG,EAAf;;AAEA,MAAI,CAACE,MAAD,IAAWA,MAAM,CAACE,MAAP,KAAkB,CAAjC,EAAoC;AAClC,WAAO,EAAP;AACD;;AAED,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACE,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;AACtC,QAAMxB,KAAK,GAAGqB,MAAM,CAACG,CAAD,CAApB;AACA,QAAMC,OAAO,GAAG1B,UAAU,CAACC,KAAD,EAAQwB,CAAR,CAA1B;;AAEA,QAAI,EAAEC,OAAO,CAACvB,IAAR,KAAiB,MAAjB,IAA2BuB,OAAO,CAACN,QAAR,CAAiBI,MAAjB,KAA4B,CAAvD,IAA4DE,OAAO,CAACtB,OAAR,KAAoB,EAAlF,CAAJ,EAA2F;AACzFsB,MAAAA,OAAO,CAACP,KAAR,GAAgBC,QAAQ,CAACI,MAAzB;;AAEA,UAAIvB,KAAK,CAAC0B,OAAN,KAAkB,CAAtB,EAAyB;AACvBP,QAAAA,QAAQ,CAACQ,IAAT,CAAcF,OAAd;AACAH,QAAAA,KAAK,CAACK,IAAN,CAAWR,QAAX;AACAA,QAAAA,QAAQ,GAAGM,OAAO,CAACN,QAAnB;AACD,OAJD,MAIO,IAAInB,KAAK,CAAC0B,OAAN,KAAkB,CAAC,CAAvB,EAA0B;AAC/BP,QAAAA,QAAQ,GAAGG,KAAK,CAACM,GAAN,EAAX;AACD,OAFM,MAEA,IAAI5B,KAAK,CAAC0B,OAAN,KAAkB,CAAtB,EAAyB;AAC9BP,QAAAA,QAAQ,CAACQ,IAAT,CAAcF,OAAd;AACD;AACF;AACF;;AAED,SAAON,QAAP;AACD","sourcesContent":["import getUniqueID from './getUniqueID';\nimport getTokenTypeByToken from './getTokenTypeByToken';\n\n/**\n *\n * @param {{type: string, tag:string, content: string, children: *, attrs: Array, meta, info, block: boolean}} token\n * @param {number} tokenIndex\n * @return {{type: string, content, tokenIndex: *, index: number, attributes: {}, children: *}}\n */\nfunction createNode(token, tokenIndex) {\n  const type = getTokenTypeByToken(token);\n  const content = token.content;\n\n  let attributes = {};\n\n  if (token.attrs) {\n    attributes = token.attrs.reduce((prev, curr) => {\n      const [name, value] = curr;\n      return { ...prev, [name]: value };\n    }, {});\n  }\n\n  return {\n    type,\n    sourceType: token.type,\n    sourceInfo: token.info,\n    sourceMeta: token.meta,\n    block: token.block,\n    key: getUniqueID(),\n    content,\n    tokenIndex,\n    index: 0,\n    attributes,\n    children: tokensToAST(token.children),\n  };\n}\n\n/**\n *\n * @param {Array<{type: string, tag:string, content: string, children: *, attrs: Array}>}tokens\n * @return {Array}\n */\nexport default function tokensToAST(tokens) {\n  let stack = [];\n  let children = [];\n\n  if (!tokens || tokens.length === 0) {\n    return [];\n  }\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const astNode = createNode(token, i);\n\n    if (!(astNode.type === 'text' && astNode.children.length === 0 && astNode.content === '')) {\n      astNode.index = children.length;\n\n      if (token.nesting === 1) {\n        children.push(astNode);\n        stack.push(children);\n        children = astNode.children;\n      } else if (token.nesting === -1) {\n        children = stack.pop();\n      } else if (token.nesting === 0) {\n        children.push(astNode);\n      }\n    }\n  }\n\n  return children;\n}\n"]},"metadata":{},"sourceType":"module"}