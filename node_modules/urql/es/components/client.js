function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

import { Component } from 'react';
import { hashString } from "../modules/hash";
import { formatTypeNames } from "../modules/typenames";

var UrqlClient =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(UrqlClient, _Component);

  function UrqlClient() {
    var _temp, _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_temp = _this = _Component.call.apply(_Component, [this].concat(args)) || this, _initialiseProps.call(_assertThisInitialized(_this)), _temp) || _assertThisInitialized(_this);
  }

  var _proto = UrqlClient.prototype;

  // Change subscription ID
  _proto.componentDidMount = function componentDidMount() {
    this.formatProps(this.props);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextProps = this.props;

    if (prevProps.query !== nextProps.query || prevProps.mutation !== nextProps.mutation) {
      this.formatProps(nextProps);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    // Unsub from change listener
    this.props.client.unsubscribe(this.subscriptionID);
  };

  _proto.render = function render() {
    var cache = {
      invalidate: this.invalidate,
      invalidateAll: this.invalidateAll,
      read: this.read,
      update: this.updateCache
    };
    return typeof this.props.children === 'function' ? this.props.children(_extends({}, this.state, this.mutations, {
      cache: cache,
      client: this.props.client,
      refetch: this.fetch,
      refreshAllFromCache: this.refreshAllFromCache
    })) : null;
  };

  return UrqlClient;
}(Component);

UrqlClient.defaultProps = {
  cache: true,
  typeInvalidation: true
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.state = {
    data: null,
    error: null,
    fetching: false,
    loaded: false
  };
  this.query = null;
  this.mutations = {};
  this.typeNames = [];
  this.subscriptionID = null;

  this.invalidate = function (queryObject) {
    var cache = _this2.props.client.cache;

    if (queryObject) {
      var stringified = JSON.stringify(formatTypeNames(queryObject));
      var hash = hashString(stringified);
      return cache.invalidate(hash);
    } else {
      return Array.isArray(_this2.props.query) ? Promise.all(_this2.props.query.map(function (q) {
        return cache.invalidate(hashString(JSON.stringify(q)));
      })) : cache.invalidate(hashString(JSON.stringify(_this2.query)));
    }
  };

  this.invalidateAll = function () {
    return _this2.props.client.cache.invalidateAll();
  };

  this.read = function (query) {
    var formatted = formatTypeNames(query);
    var stringified = JSON.stringify(formatted);
    var hash = hashString(stringified);
    return _this2.props.client.cache.read(hash);
  };

  this.updateCache = function (callback) {
    return _this2.props.client.cache.update(callback);
  };

  this.formatProps = function (props) {
    // If query exists
    if (props.query) {
      // Loop through and add typenames
      _this2.query = Array.isArray(props.query) ? props.query.map(formatTypeNames) : formatTypeNames(props.query); // Subscribe to change listener

      _this2.subscriptionID = props.client.subscribe(_this2.update); // Fetch initial data

      _this2.fetch(undefined, true);
    } // If mutation exists and has keys


    if (props.mutation) {
      _this2.mutations = {}; // Loop through and add typenames

      Object.keys(props.mutation).forEach(function (key) {
        _this2.mutations[key] = formatTypeNames(props.mutation[key]);
      }); // bind to mutate

      Object.keys(_this2.mutations).forEach(function (m) {
        var query = _this2.mutations[m].query;

        _this2.mutations[m] = function (variables) {
          return _this2.mutate({
            query: query,
            variables: _extends({}, _this2.mutations[m].variables, variables)
          });
        };

        if (!_this2.props.query) {
          _this2.forceUpdate();
        }
      });
    }
  };

  this.update = function (changedTypes, response, refresh) {
    if (refresh === true) {
      _this2.fetch();
    }

    var invalidated = false;

    if (_this2.props.shouldInvalidate) {
      invalidated = _this2.props.shouldInvalidate(changedTypes, _this2.typeNames, response, _this2.state.data);
    } else if (_this2.props.typeInvalidation !== false) {
      // Check connection typenames, derived from query, for presence of mutated typenames
      _this2.typeNames.forEach(function (typeName) {
        if (changedTypes.indexOf(typeName) !== -1) {
          invalidated = true;
        }
      });
    } // If it has any of the type names that changed


    if (invalidated) {
      // Refetch the data from the server
      _this2.fetch({
        skipCache: true
      });
    }
  };

  this.refreshAllFromCache = function () {
    return _this2.props.client.refreshAllFromCache();
  };

  this.fetch = function (opts, initial) {
    if (opts === void 0) {
      opts = {
        skipCache: false
      };
    }

    var client = _this2.props.client;
    var _opts = opts,
        skipCache = _opts.skipCache;

    if (_this2.props.cache === false) {
      skipCache = true;
    } // If query is not an array


    if (!Array.isArray(_this2.query)) {
      // Start loading state
      _this2.setState({
        error: null,
        fetching: true
      }); // Fetch the query


      client.executeQuery(_this2.query, skipCache).then(function (result) {
        // Store the typenames
        if (result.typeNames) {
          _this2.typeNames = result.typeNames;
        } // Update data


        _this2.setState({
          data: result.data,
          fetching: false,
          loaded: initial ? true : _this2.state.loaded
        });
      }).catch(function (e) {
        _this2.setState({
          error: e,
          fetching: false
        });
      });
    } else {
      // Start fetching state
      _this2.setState({
        error: null,
        fetching: true
      }); // Iterate over and fetch queries


      var partialData = [];
      return Promise.all(_this2.query.map(function (query) {
        return client.executeQuery(query, skipCache).then(function (result) {
          if (result.typeNames) {
            // Add and dedupe typenames
            _this2.typeNames = _this2.typeNames.concat(result.typeNames).filter(function (v, i, a) {
              return a.indexOf(v) === i;
            });
          }

          partialData.push(result.data);
          return result.data;
        });
      })).then(function (results) {
        _this2.setState({
          data: results,
          fetching: false,
          loaded: true
        });
      }).catch(function (e) {
        _this2.setState({
          data: partialData,
          error: e,
          fetching: false
        });
      });
    }
  };

  this.mutate = function (mutation) {
    var client = _this2.props.client; // Set fetching state

    _this2.setState({
      error: null,
      fetching: true
    });

    return new Promise(function (resolve, reject) {
      // Execute mutation
      client.executeMutation(mutation).then(function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this2.setState({
          fetching: false
        }, function () {
          resolve.apply(void 0, args);
        });
      }).catch(function (e) {
        _this2.setState({
          error: e,
          fetching: false
        }, function () {
          reject(e);
        });
      });
    });
  };
};

export { UrqlClient as default };